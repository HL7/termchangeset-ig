<div xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://hl7.org/fhir ../../input-cache/schemas/R5/fhir-single.xsd">
  
<p>
The Tinkar Reference Model is a logical model described herein using the <i>Object Management Group (OMG) 
Unified Modeling Language (UML) 2.0</i> notation to describe the structure of integrated data representation 
and change management for biomedical terminologies. Tinkar provides an architecture that delivers integrated 
terminology to the enterprise and its information systems. In doing so, it addresses the differences in 
management and structure across reference terminology, local concepts, and code lists/value sets. This 
section describes classes of objects that support a common foundational framework for terminology and 
knowledge base systems (e.g., SNOMED CT®, LOINC®, RxNorm, HL7). An implementation of Tinkar can provide a 
single representation for all terminologies required in the U.S. and other countries, while also providing a 
better foundation for managing change. Tinkar could support the operation of a variety of systems intended 
to deliver knowledge management for terminology to vendors providers, and standards-development 
organizations like HL7. 
</p>
<a name="standard model"> </a>
<h3>Standard Class Model </h3>
<img src="ClassVersionComponent.png" alt="Class Version"/>
<p>
<i>Versioned Component</i>
</p>
<p style="text-align:center;color:Gray">
Figure 3.1. Versioned Component 
</p>
<p>
The Tinkar Reference Model fulfills the requirement of capturing a complete record of all changes, including 
relevant context information. This is captured via the STAMP class using the following fields: 
</p>
<ol>
  <li>
  <b>Status:</b> A status is identified by a concept, which may be annotated with other identifying information. 
  For example: active or inactive (Requirement 19) 
  </li>
  <li>
  <b>Time:</b> Timestamps must employ a common standard, which must support precision and time zone. (Requirement 20) 
  </li>
  <li>
  <b>Author:</b> An author is identified by a concept, which may be annotated with other identifying information as required. (Requirement 21) 
  </li>
  <li>
  <b>Module:</b> Assignment to the appropriate terminology (e.g., LOINC) or terminology component (e.g., SNOMED CT®, US Extension). 
  A module is identified by a concept, which may be annotated with other identifying information. (Requirement 22) 
  </li>
  <li>
  <b>Path:</b> Specification of an object under version control within a terminology development lifecycle, e.g., 
  for distributed development, testing, staging, or production. A path is a common synomyn for “branch” as 
  used in current software version control best practices/literature. A path is identified by a concept, 
  which may be annotated with other identifying information. A core set of paths is necessary to support 
  publication to external organizations. (Requirement 23) 
  </li>
</ol>
<p>
These elements together are referred to by the acronym “<b>STAMP</b>,” as described previously. Every new assertion, 
whether a new component or a change to an existing component, must have a STAMP to determine when it is to 
be used. The STAMP properties support the ability to apply terminology components for specific purposes. 
For example, 
</p>
<ul>
  <li>
  “Path” can be used to test provisional content without physically swapping out systems. 
  </li>
  <li>
  “Module” can be used to filter out work that has not been authorized by the enterprise. 
  </li>
  <li>
  “Time” supports the ability to apply CDS rules as they would have looked in the past. 
  </li>
</ul>
<p>
The Tinkar Reference Model does not merely support the ability to “STAMP” components; it asserts a 
requirement that all changes have a STAMP. STAMP assertions are unversioned IdentifiedComponents that are 
referenced by the components they scope. Since STAMP uses versioned concepts (that have a STAMP), having the 
STAMP as a versioned component would lead to an infinite regress. 
</p>
<p>
Not all terminology systems contain all the information recorded in STAMP, but defaults can be used in cases 
where it is missing. For example, SNOMED CT contains the Status, Time, and Module but do not distribute the 
Path or Author. Since most terminologies only release a Production path, the Path could be defaulted to 
Production Path and the Author could be defaulted to SNOMED CT Author. 
</p>
<p>
All IdentifedComponents in the knowledge base will consist of a series of change records, called 
ComponentVersions, (beginning with the “Create” version), all associated to an underlying 
ComponentChronology. 
</p>
<p>
A Components Chronology only has properties attributed to it by its versions. Looking at the 
IdentifiedComponent through different sets of changes (published version, geographically defined set of 
modules, historical timestamp) may reveal substantially different IdentifedComponents. 
</p>
<a name="component types"> </a>
<h3>Component Types</h3>
<img src="ComponentTypes.png" alt="Component Types"/>
<p>
<i>Component Types</i>
</p>
<p style="text-align:center;color:Gray">
Figure 3.2. Component Types
</p>
<p>
All Components in Tinkar are uniquely identified using UUIDs. A Component will be represented by an array of 
UUIDs with at least one UUID, but can be represented by more than one UUID in the case of a concept being 
derived from multiple sources. For example, the concept Acetaminophen (which exists in SNOMED CT®, LOINC, 
and RxNorm) could have a UUID from each terminology and be represented as an array of UUIDs for this single 
concept within a Tinkar implementation. 
</p>
<p>
A Concept is identified using UUIDs and contains no information. To assemble groups of assertions and to 
provide information about Concepts, Tinkar uses a construct called a <b>Semantic</b>. A Semantic is a class 
containing a set of predicates and objects about a subject. A semantic adds meaning to the components it 
references, through the fields it contains. A Semantic supports the specification of value sets, 
compositional definitions, and other components requiring internal structure, and it specifies the nature 
of the compositional relationship explicitly. 
</p>
<p>
The Semantic class uses a Concept to define the relationship between the value(s) and the Concept; the 
value itself may be either a concept or some other kind of data type, such as a string. This creates the 
ability to assemble assertions into more complex structures. 
</p>
<img src="CompositionalSemantics.png" alt="Compositional Semantics"/>
<p>
<i>Compositional Semantics</i>
</p>
<p style="text-align:center;color:Gray">
Figure 3.3. Compositional Semantics
</p>
<p>
As discussed earlier, if an author makes a change to an IdentifiedComponent, the prior Version is unchanged, 
but a new version - with the appropriate STAMP information - is recorded. Users viewing the Concept and 
associated Semantics in the prior context (i.e., as of the prior time, if no other STAMP element has 
changed) will see the old values; users viewing the Concept and associated Semantics in the new context 
will see the new values. 
</p>
<p>
Since it is versioned, a Semantic is manifested as a <b>SemanticChronology</b>, containing a set of 
<b>SemanticVersions</b>. SemanticVersion is a single instance of a Semantic with a STAMP, and a SemanticChronology 
is the set of versions having a STAMP for a Semantic. Concepts, too, are manifest as collections: a 
<b>ConceptChronology</b> consisting of a set of <b>ConceptVersions</b>. ConceptVersion is a single instance of an 
identifier for a concept with a STAMP and the ConceptChronology is the set of versions having a STAMP for a 
concept. A concept identifier specifies a ConceptChronology; specifying a ConceptVersion requires a rule or 
parameter for selecting among STAMP values. 
</p>
<p>
If other IdentifiedComponents depend on the changed concept, these IdentifiedComponents can be identified 
by relationships in the Semantics. The Semantics can assert rules for how to manage these changes. A 
Semantic defining a value set for data entry might automatically accept any deactivations from the source 
system authority, while a Semantic defining a value set for research might automatically decline to adopt 
deactivations, or do so based on whether there are extant operational values. Escalating such decisions for 
human adjudication or review at multiple levels is also always an option. Systems might adopt any number of 
methods for dealing with identified changes: the important thing is to ensure the changes can be identified 
consistently. 
</p>
<a name="field data types"> </a>
<h3>Field Data Types</h3>
<p>
Tinkar supports the following field data types for use with Semantics. 
</p>
<ol>
  <li>
  String - a sequence of characters, either as a literal constant or as a variable. 
  Strings could be used to represent terms from code systems or URLs, textual definitions, etc. 
  </li>
  <li>
  Integer - data type that represents some range of mathematical integers. 
  </li>
  <li>
  Float - represents values as high-precision fractional values. 
  </li>
  <li>
  Boolean - represents the values true and false. 
  </li>
  <li>
  Byte Array - an array of 8-bit signed two's complement integers. 
  </li>
  <li>
  Directed Graph or Digraph - a graph whose edges are ordered pairs of vertices. Each edge can be 
  followed from one vertex to another vertex. 
  </li>
  <li>
  Instant - models a single instantaneous point on a timeline. 
  </li>
  <li>
  Planar Point - position in a two-dimensional space (a plane). 
  </li>
  <li>
  Spatial Point - position in a three-dimensional space. 
  </li>
  <li>
  Component ID List - an ordered list of Component IDs. 
  </li>
  <li>
  Component ID Set - an unordered list of Component IDs. 
  </li>
  <li>
  UUID (Universally Unique Identifier) - A 128-bit number used to identify information in computer systems. 
  </li>
  <li>
  Directed Tree or Ditree - a graph obtained from an undirected tree by replacing each undirected edge 
  by two directed edges with opposite directions. 
  </li>
  <li>
  DiGraph - A graph in which a set of objects are connected where all the edges are directed from one vertex to another. 
  </li>
  <li>
  Vertex - The fundamental unit of data that makes up a graph or tree. 
  <ol type="a">
    <li>
    In Tinkar, property graphs are used as a general-purpose data pattern to represent an abstract syntax 
    tree (AST), such as OWL EL++. This allows for data types without requiring custom nodes.
    <ol type="i">
      <li>
      An AST may be used “during semantic analysis, where the compiler checks for correct usage of the 
      elements of the program and the language. The compiler also generates symbol tables based on the 
      AST during semantic analysis. A complete traversal of the tree allows verification of the correctness 
      of the program. After verifying correctness, the AST serves as the base for code generation. The AST 
      is often used to generate an intermediate representation, sometimes called an intermediate language, 
      for the code generation.” <a href="#footnote15">[15]</a>
      </li>
      <li>
      An AST is made up of nodes and branches. In Tinkar, every tree will always have roots, but they are 
      specific: “An OWL EL root” vs. a “BPMN root”, etc. Each node must have 0 or more children. 
      </li>
    </ol>
    </li>
    <li>
    Here is an example of Tinkar output of semantics that reference multiple concepts.
    <img src="VertexExample.png" alt="Vertex Example"/>
    In this output, one can see a sufficient set and necessary set. Bulleted items are properties in the 
    node. The output is printed as a “depth first search.” Each depth adds 3 characters of padding and 
    shows how OWL EL++ definitions, using only terminology and a standard property graph data structure, 
    are represented. The 1st one is node index 0 which has a child of node index 8. Node index 0 is the OWL 
    EL++ definition root. Node 8 points to Node 7, and the meaning of Node 8 is that it is a necessary set. 
    Node 7 is 'And' and points to Node 5,1,6. Node 5's meaning is 'Role Type', Value is 'Role group', and 
    its other property is 'Role Operator.' Node 5 points to Node 4. Node 4 is 'And.' Node 3 is 'Role Type.'
    Node 2 is Concept Reference. 7 also points to 1 and 6 (Concept References). 
    </li>
    <li>
    The property graph model demonstrates that each vertex has a meaning. Tinkar can use concepts to 
    represent anything end users might need at nodes. This allows for data types without requiring custom 
    nodes. With no changes to the underlying data structures, Tinkar can represent more than OWL EL++. With 
    updates to terminology, Tinkar can represent any parsable standard, such as BPMN and DMN, using this 
    property graph model and a proper set of terminology concepts and semantics represented using Tinkar. 
    </li>
  </ol>
  </li>
</ol>
<a name="pattern"> </a>
<h3>Pattern (For Semantics)</h3>
<p>
The Tinkar Reference Model defines a first-class feature of the model, the <b>Pattern</b> (<b>PatternVersion</b> and 
<b>PatternChronology</b>). A Pattern is a class defining a set of predicates and object types that can be asserted 
about a class of subjects. All Semantics follow Patterns. A PatternVersion is a single instance of a 
pattern with a STAMP and a PatternChronology is the set of versions having a STAMP for a pattern. This 
feature asserts patterns that Semantic components can follow, like an XML or RDF Schema. 
</p>
<img src="SemanticDefinition.png" alt="Semantic Definition"/>
<p>
<i>Pattern</i>
</p>
<p style="text-align:center;color:Gray">
Figure 3.4. Pattern
</p>
<p>
Using the Pattern, Semantics with varying fields and data types can be specified to represent any 
structure needed to provide meaning to a concept. For example, if a field within a semantic is used to 
describe an SDO's website, the Meaning would be “URL,” DataType of “String,” and Purpose of “Website.” The 
Pattern would then contain an array of these FieldDefinitions. 
</p>

<hr />
<p id="footnote15">
[15] Abstract syntax tree. Wikipedia; 2020. Available from: https://en.wikipedia.org/wiki/Abstract_syntax_tree.
</p>
</div>
